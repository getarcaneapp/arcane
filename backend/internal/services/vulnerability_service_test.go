package services

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net"
	"os"
	"testing"

	containertypes "github.com/docker/docker/api/types/container"
	mounttypes "github.com/docker/docker/api/types/mount"
	"github.com/getarcaneapp/arcane/types/vulnerability"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestIsExpectedDockerStreamEndErrorInternal(t *testing.T) {
	tests := []struct {
		name string
		err  error
		want bool
	}{
		{name: "nil", err: nil, want: false},
		{name: "eof", err: io.EOF, want: true},
		{name: "wrapped eof", err: fmt.Errorf("wrapped: %w", io.EOF), want: true},
		{name: "net err closed", err: net.ErrClosed, want: true},
		{name: "closed network connection", err: errors.New("read tcp 127.0.0.1:1234->127.0.0.1:5678: use of closed network connection"), want: true},
		{name: "broken pipe", err: errors.New("write: broken pipe"), want: true},
		{name: "connection reset by peer", err: errors.New("read: connection reset by peer"), want: true},
		{name: "unexpected", err: errors.New("some other error"), want: false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			require.Equal(t, tt.want, isExpectedDockerStreamEndErrorInternal(tt.err))
		})
	}
}

func TestDecodeTrivyReportFromFileInternal_LargePayload(t *testing.T) {
	tmpFile, err := os.CreateTemp("", "trivy-report-*.json")
	require.NoError(t, err)
	defer func() {
		require.NoError(t, os.Remove(tmpFile.Name()))
	}()
	defer func() {
		require.NoError(t, tmpFile.Close())
	}()

	const vulnCount = 4000
	vulns := make([]vulnerability.TrivyVulnerability, 0, vulnCount)
	for i := 0; i < vulnCount; i++ {
		vulns = append(vulns, vulnerability.TrivyVulnerability{
			VulnerabilityID:  fmt.Sprintf("CVE-2026-%04d", i),
			PkgName:          fmt.Sprintf("pkg-%d", i),
			InstalledVersion: "1.0.0",
			FixedVersion:     "1.0.1",
			Severity:         "HIGH",
		})
	}

	report := vulnerability.TrivyReport{
		SchemaVersion: 2,
		ArtifactName:  "example/image:latest",
		ArtifactType:  "container_image",
		Results: []vulnerability.TrivyResults{
			{
				Target:          "alpine:3.20",
				Class:           "os-pkgs",
				Type:            "alpine",
				Vulnerabilities: vulns,
			},
		},
	}

	encoder := json.NewEncoder(tmpFile)
	require.NoError(t, encoder.Encode(report))

	decoded, err := decodeTrivyReportFromFileInternal(tmpFile)
	require.NoError(t, err)
	require.NotNil(t, decoded)
	require.Equal(t, report.ArtifactName, decoded.ArtifactName)
	require.Len(t, decoded.Results, 1)
	require.Len(t, decoded.Results[0].Vulnerabilities, vulnCount)
}

func TestCleanupTrivyLogTempFilesInternal_RemovesFiles(t *testing.T) {
	stdoutFile, err := os.CreateTemp("", "trivy-stdout-test-*")
	require.NoError(t, err)
	stderrFile, err := os.CreateTemp("", "trivy-stderr-test-*")
	require.NoError(t, err)

	stdoutPath := stdoutFile.Name()
	stderrPath := stderrFile.Name()

	_, err = stdoutFile.WriteString("stdout")
	require.NoError(t, err)
	_, err = stderrFile.WriteString("stderr")
	require.NoError(t, err)

	cleanupTrivyLogTempFilesInternal(context.Background(), stdoutFile, stderrFile)

	_, err = os.Stat(stdoutPath)
	require.Error(t, err)
	require.True(t, os.IsNotExist(err))

	_, err = os.Stat(stderrPath)
	require.Error(t, err)
	require.True(t, os.IsNotExist(err))
}

func TestIsNanoCPUsUnsupportedErrorInternal(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		err  error
		want bool
	}{
		{
			name: "matches issue error message",
			err:  errors.New("Error response from daemon: NanoCPUs can not be set, as your kernel does not support CPU CFS scheduler or the cgroup is not mounted"),
			want: true,
		},
		{
			name: "matches cannot variant",
			err:  errors.New("NanoCPUs cannot be set on this daemon"),
			want: true,
		},
		{
			name: "matches cfs quota warning",
			err:  errors.New("failed to create container: no cpu cfs quota support"),
			want: true,
		},
		{
			name: "ignores unrelated errors",
			err:  errors.New("failed to create container: image not found"),
			want: false,
		},
		{
			name: "nil error",
			err:  nil,
			want: false,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			assert.Equal(t, tc.want, isNanoCPUsUnsupportedErrorInternal(tc.err))
		})
	}
}

func TestCloneHostConfigWithoutNanoCPUsInternal(t *testing.T) {
	t.Parallel()

	original := &containertypes.HostConfig{
		AutoRemove: true,
		Mounts: []mounttypes.Mount{
			{
				Type:   mounttypes.TypeBind,
				Source: "/var/run/docker.sock",
				Target: "/var/run/docker.sock",
			},
		},
		Resources: containertypes.Resources{
			NanoCPUs:   trivyMaxCPUNano,
			Memory:     trivyMaxMemoryBytes,
			MemorySwap: trivyMaxMemoryBytes,
		},
	}

	cloned := cloneHostConfigWithoutNanoCPUsInternal(original)
	require.NotNil(t, cloned)

	assert.Zero(t, cloned.NanoCPUs)
	assert.Equal(t, trivyMaxMemoryBytes, cloned.Memory)
	assert.Equal(t, trivyMaxMemoryBytes, cloned.MemorySwap)
	assert.Equal(t, original.AutoRemove, cloned.AutoRemove)
	assert.Equal(t, original.Mounts, cloned.Mounts)

	// Ensure original is unchanged
	assert.Equal(t, trivyMaxCPUNano, original.NanoCPUs)
}
