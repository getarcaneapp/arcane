package services

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/getarcaneapp/arcane/backend/internal/database"
	"github.com/getarcaneapp/arcane/backend/internal/models"
	"github.com/getarcaneapp/arcane/backend/internal/utils/pagination"
	"github.com/getarcaneapp/arcane/backend/internal/utils/timeouts"
	"github.com/getarcaneapp/arcane/types/vulnerability"
	glsqlite "github.com/glebarez/sqlite"
	containertypes "github.com/moby/moby/api/types/container"
	mounttypes "github.com/moby/moby/api/types/mount"
	"github.com/stretchr/testify/require"
	"gorm.io/gorm"
)

func TestIsExpectedDockerStreamEndErrorInternal(t *testing.T) {
	tests := []struct {
		name string
		err  error
		want bool
	}{
		{name: "nil", err: nil, want: false},
		{name: "eof", err: io.EOF, want: true},
		{name: "wrapped eof", err: fmt.Errorf("wrapped: %w", io.EOF), want: true},
		{name: "net err closed", err: net.ErrClosed, want: true},
		{name: "closed network connection", err: errors.New("read tcp 127.0.0.1:1234->127.0.0.1:5678: use of closed network connection"), want: true},
		{name: "broken pipe", err: errors.New("write: broken pipe"), want: true},
		{name: "connection reset by peer", err: errors.New("read: connection reset by peer"), want: true},
		{name: "unexpected", err: errors.New("some other error"), want: false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			require.Equal(t, tt.want, isExpectedDockerStreamEndErrorInternal(tt.err))
		})
	}
}

func TestDecodeTrivyReportFromFileInternal_LargePayload(t *testing.T) {
	tmpFile, err := os.CreateTemp("", "trivy-report-*.json")
	require.NoError(t, err)
	defer func() {
		require.NoError(t, os.Remove(tmpFile.Name()))
	}()
	defer func() {
		require.NoError(t, tmpFile.Close())
	}()

	const vulnCount = 4000
	vulns := make([]vulnerability.TrivyVulnerability, 0, vulnCount)
	for i := range vulnCount {
		vulns = append(vulns, vulnerability.TrivyVulnerability{
			VulnerabilityID:  fmt.Sprintf("CVE-2026-%04d", i),
			PkgName:          fmt.Sprintf("pkg-%d", i),
			InstalledVersion: "1.0.0",
			FixedVersion:     "1.0.1",
			Severity:         "HIGH",
		})
	}

	report := vulnerability.TrivyReport{
		SchemaVersion: 2,
		ArtifactName:  "example/image:latest",
		ArtifactType:  "container_image",
		Results: []vulnerability.TrivyResults{
			{
				Target:          "alpine:3.20",
				Class:           "os-pkgs",
				Type:            "alpine",
				Vulnerabilities: vulns,
			},
		},
	}

	encoder := json.NewEncoder(tmpFile)
	require.NoError(t, encoder.Encode(report))

	decoded, err := decodeTrivyReportFromFileInternal(tmpFile)
	require.NoError(t, err)
	require.NotNil(t, decoded)
	require.Equal(t, report.ArtifactName, decoded.ArtifactName)
	require.Len(t, decoded.Results, 1)
	require.Len(t, decoded.Results[0].Vulnerabilities, vulnCount)
}

func TestDecodeTrivyReportFromFileInternal_RecoversFromPrefixedAndTrailingNoise(t *testing.T) {
	tmpFile, err := os.CreateTemp("", "trivy-report-noisy-*.json")
	require.NoError(t, err)
	defer func() {
		require.NoError(t, os.Remove(tmpFile.Name()))
	}()
	defer func() {
		require.NoError(t, tmpFile.Close())
	}()

	report := vulnerability.TrivyReport{
		SchemaVersion: 2,
		ArtifactName:  "ghcr.io/getarcaneapp/example:latest",
		ArtifactType:  "container_image",
		Results: []vulnerability.TrivyResults{
			{Target: "alpine:3.20", Class: "os-pkgs", Type: "alpine"},
		},
	}

	reportBytes, err := json.Marshal(report)
	require.NoError(t, err)

	_, err = tmpFile.WriteString("WARN scanner warming cache\n")
	require.NoError(t, err)
	_, err = tmpFile.Write(reportBytes)
	require.NoError(t, err)
	_, err = tmpFile.WriteString("\nINFO scan completed\n")
	require.NoError(t, err)

	decoded, err := decodeTrivyReportFromFileInternal(tmpFile)
	require.NoError(t, err)
	require.NotNil(t, decoded)
	require.Equal(t, report.ArtifactName, decoded.ArtifactName)
	require.Equal(t, report.SchemaVersion, decoded.SchemaVersion)
}

func TestDecodeTrivyReportFromFileInternal_SelectsReportFromMultipleJSONObjects(t *testing.T) {
	tmpFile, err := os.CreateTemp("", "trivy-report-multi-json-*.json")
	require.NoError(t, err)
	defer func() {
		require.NoError(t, os.Remove(tmpFile.Name()))
	}()
	defer func() {
		require.NoError(t, tmpFile.Close())
	}()

	report := vulnerability.TrivyReport{
		SchemaVersion: 2,
		ArtifactName:  "ghcr.io/getarcaneapp/example:stable",
		ArtifactType:  "container_image",
		Results: []vulnerability.TrivyResults{
			{Target: "debian:12", Class: "os-pkgs", Type: "debian"},
		},
	}

	reportBytes, err := json.Marshal(report)
	require.NoError(t, err)

	_, err = tmpFile.WriteString(`{"action":"vulnerability_scan","success":false}` + "\n")
	require.NoError(t, err)
	_, err = tmpFile.Write(reportBytes)
	require.NoError(t, err)

	decoded, err := decodeTrivyReportFromFileInternal(tmpFile)
	require.NoError(t, err)
	require.NotNil(t, decoded)
	require.Equal(t, report.ArtifactName, decoded.ArtifactName)
	require.Equal(t, report.SchemaVersion, decoded.SchemaVersion)
}

func TestDecodeTrivyReportFromFileInternal_HandlesConcatenatedJSONObjects(t *testing.T) {
	tmpFile, err := os.CreateTemp("", "trivy-report-concatenated-*.json")
	require.NoError(t, err)
	defer func() {
		require.NoError(t, os.Remove(tmpFile.Name()))
	}()
	defer func() {
		require.NoError(t, tmpFile.Close())
	}()

	report := vulnerability.TrivyReport{
		SchemaVersion: 2,
		ArtifactName:  "ghcr.io/getarcaneapp/example:concat",
		ArtifactType:  "container_image",
		Results: []vulnerability.TrivyResults{
			{Target: "ubuntu:24.04", Class: "os-pkgs", Type: "ubuntu"},
		},
	}

	reportBytes, err := json.Marshal(report)
	require.NoError(t, err)

	_, err = tmpFile.Write(reportBytes)
	require.NoError(t, err)
	_, err = tmpFile.WriteString(`{"message":"done"}`)
	require.NoError(t, err)

	decoded, err := decodeTrivyReportFromFileInternal(tmpFile)
	require.NoError(t, err)
	require.NotNil(t, decoded)
	require.Equal(t, report.ArtifactName, decoded.ArtifactName)
	require.Equal(t, report.SchemaVersion, decoded.SchemaVersion)
}

func TestCleanupTrivyLogTempFilesInternal_RemovesFiles(t *testing.T) {
	stdoutFile, err := os.CreateTemp("", "trivy-stdout-test-*")
	require.NoError(t, err)
	stderrFile, err := os.CreateTemp("", "trivy-stderr-test-*")
	require.NoError(t, err)

	stdoutPath := stdoutFile.Name()
	stderrPath := stderrFile.Name()

	_, err = stdoutFile.WriteString("stdout")
	require.NoError(t, err)
	_, err = stderrFile.WriteString("stderr")
	require.NoError(t, err)

	cleanupTrivyLogTempFilesInternal(context.Background(), stdoutFile, stderrFile)

	_, err = os.Stat(stdoutPath)
	require.Error(t, err)
	require.True(t, os.IsNotExist(err))

	_, err = os.Stat(stderrPath)
	require.Error(t, err)
	require.True(t, os.IsNotExist(err))
}

func TestBuildTrivyContainerResourcesInternal_Defaults(t *testing.T) {
	resources, applyLimits := buildTrivyContainerResourcesInternal(nil)

	require.True(t, applyLimits)
	require.Equal(t, int64(1_000_000_000), resources.NanoCPUs)
	require.Equal(t, int64(0), resources.Memory)
	require.Equal(t, int64(0), resources.MemorySwap)
}

func TestBuildTrivyContainerResourcesInternal_LimitsDisabled(t *testing.T) {
	cfg := &models.Settings{
		TrivyResourceLimitsEnabled: models.SettingVariable{Value: "false"},
		TrivyCpuLimit:              models.SettingVariable{Value: "2"},
		TrivyMemoryLimitMb:         models.SettingVariable{Value: "2048"},
	}

	resources, applyLimits := buildTrivyContainerResourcesInternal(cfg)

	require.False(t, applyLimits)
	require.Equal(t, int64(0), resources.NanoCPUs)
	require.Equal(t, int64(0), resources.Memory)
	require.Equal(t, int64(0), resources.MemorySwap)
}

func TestBuildTrivyContainerResourcesInternal_CustomLimits(t *testing.T) {
	cfg := &models.Settings{
		TrivyResourceLimitsEnabled: models.SettingVariable{Value: "true"},
		TrivyCpuLimit:              models.SettingVariable{Value: "2.5"},
		TrivyMemoryLimitMb:         models.SettingVariable{Value: "2048"},
	}

	resources, applyLimits := buildTrivyContainerResourcesInternal(cfg)

	require.True(t, applyLimits)
	require.Equal(t, int64(2_500_000_000), resources.NanoCPUs)
	require.Equal(t, int64(2_147_483_648), resources.Memory)
	require.Equal(t, int64(2_147_483_648), resources.MemorySwap)
}

func TestBuildTrivyCommandArgs_WithCacheDir(t *testing.T) {
	svc := &VulnerabilityService{}
	outputPath := "/tmp/trivy-result-test.json"

	cmdArgs, tempFiles := svc.buildTrivyCommandArgs(context.Background(), "alpine:3.20", "", "", "/tmp/trivy-cache", outputPath)

	require.Empty(t, tempFiles)
	require.Contains(t, cmdArgs, "--cache-dir")
	require.Contains(t, cmdArgs, "/tmp/trivy-cache")
	require.Contains(t, cmdArgs, "--output")
	require.Contains(t, cmdArgs, outputPath)
	require.Equal(t, "alpine:3.20", cmdArgs[len(cmdArgs)-1])
}

func TestBuildTrivyCommandArgs_WithoutCacheDir(t *testing.T) {
	svc := &VulnerabilityService{}
	outputPath := "/tmp/trivy-result-test.json"

	cmdArgs, tempFiles := svc.buildTrivyCommandArgs(context.Background(), "alpine:3.20", "", "", "", outputPath)

	require.Empty(t, tempFiles)
	require.NotContains(t, cmdArgs, "--cache-dir")
	require.Contains(t, cmdArgs, "--output")
	require.Contains(t, cmdArgs, outputPath)
	require.Equal(t, "alpine:3.20", cmdArgs[len(cmdArgs)-1])
}

func TestBuildTrivyHostConfig_ExcludesResourcesWhenLimitsDisabled(t *testing.T) {
	resources := containertypes.Resources{
		NanoCPUs:   int64(2_000_000_000),
		Memory:     int64(1_073_741_824),
		MemorySwap: int64(1_073_741_824),
	}

	hostConfig := buildTrivyHostConfig("cache-volume", nil, resources, "", false, "bridge")
	require.Equal(t, containertypes.NetworkMode("bridge"), hostConfig.NetworkMode)
	require.Equal(t, int64(0), hostConfig.Resources.NanoCPUs)
	require.Equal(t, int64(0), hostConfig.Resources.Memory)
	require.Equal(t, int64(0), hostConfig.Resources.MemorySwap)
}

func TestBuildTrivyHostConfig_IncludesResourcesWhenLimitsEnabled(t *testing.T) {
	resources := containertypes.Resources{
		NanoCPUs:   int64(2_000_000_000),
		Memory:     int64(1_073_741_824),
		MemorySwap: int64(1_073_741_824),
	}

	hostConfig := buildTrivyHostConfig("cache-volume", nil, resources, "", true, "arcane-external")
	require.Equal(t, containertypes.NetworkMode("arcane-external"), hostConfig.NetworkMode)
	require.Equal(t, resources.NanoCPUs, hostConfig.Resources.NanoCPUs)
	require.Equal(t, resources.Memory, hostConfig.Resources.Memory)
	require.Equal(t, resources.MemorySwap, hostConfig.Resources.MemorySwap)
}

func TestBuildTrivyHostConfig_UsesCPUSetAndClearsNanoCPUs(t *testing.T) {
	resources := containertypes.Resources{
		NanoCPUs:   int64(2_000_000_000),
		Memory:     int64(1_073_741_824),
		MemorySwap: int64(1_073_741_824),
	}

	hostConfig := buildTrivyHostConfig("cache-volume", nil, resources, "0-1", true, "bridge")
	require.Equal(t, containertypes.NetworkMode("bridge"), hostConfig.NetworkMode)
	require.Equal(t, int64(0), hostConfig.Resources.NanoCPUs)
	require.Equal(t, "0-1", hostConfig.Resources.CpusetCpus)
	require.Equal(t, resources.Memory, hostConfig.Resources.Memory)
	require.Equal(t, resources.MemorySwap, hostConfig.Resources.MemorySwap)
}

func TestNormalizeTrivyNetworkModeInternal(t *testing.T) {
	require.Equal(t, DefaultTrivyNetworkMode, normalizeTrivyNetworkModeInternal(""))
	require.Equal(t, DefaultTrivyNetworkMode, normalizeTrivyNetworkModeInternal(" \t\n "))
	require.Equal(t, "arcane-external", normalizeTrivyNetworkModeInternal("arcane-external"))
}

func TestIsSynologyDockerHostInternal(t *testing.T) {
	// DS220+ (Kernel 4.x): single-line
	require.True(t, isSynologyDockerHostInternal("Synology NAS"))
	// DS925+ (Kernel 5.x): OS field contains a newline before "(containerized)"
	require.True(t, isSynologyDockerHostInternal("Synology NAS\n (containerized)"))
	// Variation: Windows-style line ending
	require.True(t, isSynologyDockerHostInternal("Synology NAS\r\n (containerized)"))
	// Case-insensitive
	require.True(t, isSynologyDockerHostInternal("synology nas"))
	// Padded with spaces
	require.True(t, isSynologyDockerHostInternal("  Synology NAS  "))
	// Empty / non-Synology
	require.False(t, isSynologyDockerHostInternal(""))
	require.False(t, isSynologyDockerHostInternal("Ubuntu 24.04.1 LTS"))
	require.False(t, isSynologyDockerHostInternal("Ubuntu 24.04.1 LTS\n (containerized)"))
}

func TestBuildTrivyCPUSetInternal(t *testing.T) {
	require.Equal(t, "", buildTrivyCPUSetInternal(0, 4))
	require.Equal(t, "0", buildTrivyCPUSetInternal(1_000_000_000, 4))
	require.Equal(t, "0-1", buildTrivyCPUSetInternal(2_500_000_000, 4))
	require.Equal(t, "0-1", buildTrivyCPUSetInternal(3_000_000_000, 2))
	require.Equal(t, "0", buildTrivyCPUSetInternal(1_000_000_000, 0))
}

func TestGetTrivySingleScanCacheDirForSlotInternal(t *testing.T) {
	svc := &VulnerabilityService{}

	require.Equal(t, "/root/.cache/arcane-scan-slots/slot-0", svc.getTrivySingleScanCacheDirForSlotInternal(0))
	require.Equal(t, "/root/.cache/arcane-scan-slots/slot-2", svc.getTrivySingleScanCacheDirForSlotInternal(2))
	// Negative slot IDs should normalize to slot-0
	require.Equal(t, "/root/.cache/arcane-scan-slots/slot-0", svc.getTrivySingleScanCacheDirForSlotInternal(-1))
}

func TestGetTrivyScanSlotChannelInternal_PrefillsSlots(t *testing.T) {
	svc := &VulnerabilityService{}

	slotCh := svc.getTrivyScanSlotChannelInternal(3)
	require.NotNil(t, slotCh)
	require.Equal(t, 3, cap(slotCh))
	require.Equal(t, 3, len(slotCh))

	seen := map[int]bool{}
	for range 3 {
		slotID := <-slotCh
		seen[slotID] = true
	}

	require.True(t, seen[0])
	require.True(t, seen[1])
	require.True(t, seen[2])
	require.Equal(t, 0, len(slotCh))
}

func TestTrivyMountSummariesInternal(t *testing.T) {
	require.Nil(t, trivyMountSummariesInternal(nil))

	hostConfig := &containertypes.HostConfig{
		Mounts: []mounttypes.Mount{
			{
				Type:   mounttypes.TypeBind,
				Source: "/var/run/docker.sock",
				Target: "/var/run/docker.sock",
			},
			{
				Type:   mounttypes.TypeVolume,
				Source: "arcane-trivy-cache",
				Target: "/root/.cache",
			},
			{
				Type:   mounttypes.TypeTmpfs,
				Target: "/tmp",
			},
		},
	}

	require.Equal(t,
		[]string{
			"/var/run/docker.sock:/var/run/docker.sock",
			"arcane-trivy-cache:/root/.cache",
			"tmpfs:/tmp",
		},
		trivyMountSummariesInternal(hostConfig),
	)
}

func TestTruncateTrivyLogOutputInternal(t *testing.T) {
	require.Equal(t, "", truncateTrivyLogOutputInternal("", 32))
	require.Equal(t, "keep me", truncateTrivyLogOutputInternal("  keep me  ", 32))

	longOutput := strings.Repeat("x", 80)
	truncated := truncateTrivyLogOutputInternal(longOutput, 16)
	require.Equal(t, strings.Repeat("x", 16)+" ...<truncated>", truncated)
}

func TestTrivyContainerWaitTimeoutInternal(t *testing.T) {
	require.Equal(t, timeouts.DefaultTrivyScan+timeouts.DefaultDockerAPI, trivyContainerWaitTimeoutInternal(""))
	require.Equal(t, 5*time.Minute+timeouts.DefaultDockerAPI, trivyContainerWaitTimeoutInternal("5m"))
	require.Equal(t, timeouts.DefaultTrivyScan+timeouts.DefaultDockerAPI, trivyContainerWaitTimeoutInternal("not-a-duration"))
	require.Equal(t, timeouts.DefaultTrivyScan+timeouts.DefaultDockerAPI, trivyContainerWaitTimeoutInternal("0s"))
}

func TestAwaitContainerWaitResponseInternal_Status(t *testing.T) {
	statusCh := make(chan containertypes.WaitResponse, 1)
	errCh := make(chan error)
	statusCh <- containertypes.WaitResponse{StatusCode: 12}

	status, err := awaitContainerWaitResponseInternal(context.Background(), statusCh, errCh)
	require.NoError(t, err)
	require.Equal(t, int64(12), status)
}

func TestAwaitContainerWaitResponseInternal_Error(t *testing.T) {
	statusCh := make(chan containertypes.WaitResponse)
	errCh := make(chan error, 1)
	errCh <- errors.New("boom")

	status, err := awaitContainerWaitResponseInternal(context.Background(), statusCh, errCh)
	require.Error(t, err)
	require.Contains(t, err.Error(), "boom")
	require.Equal(t, int64(0), status)
}

func TestAwaitContainerWaitResponseInternal_ClosedErrorChannelStillReadsStatus(t *testing.T) {
	statusCh := make(chan containertypes.WaitResponse, 1)
	errCh := make(chan error)

	close(errCh)
	statusCh <- containertypes.WaitResponse{StatusCode: 7}

	status, err := awaitContainerWaitResponseInternal(context.Background(), statusCh, errCh)
	require.NoError(t, err)
	require.Equal(t, int64(7), status)
}

func TestAwaitContainerWaitResponseInternal_ContextDone(t *testing.T) {
	statusCh := make(chan containertypes.WaitResponse)
	errCh := make(chan error)
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Millisecond)
	defer cancel()

	status, err := awaitContainerWaitResponseInternal(ctx, statusCh, errCh)
	require.Error(t, err)
	require.ErrorIs(t, err, context.DeadlineExceeded)
	require.Equal(t, int64(0), status)
}

func TestAwaitContainerWaitResponseInternal_NoStatus(t *testing.T) {
	statusCh := make(chan containertypes.WaitResponse)
	errCh := make(chan error)
	close(statusCh)
	close(errCh)

	status, err := awaitContainerWaitResponseInternal(context.Background(), statusCh, errCh)
	require.Error(t, err)
	require.Contains(t, err.Error(), "ended without status")
	require.Equal(t, int64(0), status)
}

func setupVulnerabilityScanTestDB(t *testing.T) *database.DB {
	t.Helper()
	dsn := fmt.Sprintf("file:vulnerability-scan-test-%d?mode=memory&cache=shared", time.Now().UnixNano())
	db, err := gorm.Open(glsqlite.Open(dsn), &gorm.Config{})
	require.NoError(t, err)
	require.NoError(t, db.AutoMigrate(&models.VulnerabilityScanRecord{}, &models.VulnerabilityIgnore{}))
	return &database.DB{DB: db}
}

func TestVulnerabilityService_DeleteScanResultsByImageIDs(t *testing.T) {
	ctx := context.Background()
	db := setupVulnerabilityScanTestDB(t)
	svc := &VulnerabilityService{db: db}

	records := []models.VulnerabilityScanRecord{
		{ID: "sha256:img1", ImageName: "nginx:latest", Status: models.ScanStatusCompleted, ScanTime: time.Now()},
		{ID: "sha256:img2", ImageName: "redis:7", Status: models.ScanStatusCompleted, ScanTime: time.Now()},
		{ID: "sha256:img3", ImageName: "postgres:16", Status: models.ScanStatusCompleted, ScanTime: time.Now()},
	}
	for i := range records {
		require.NoError(t, db.Create(&records[i]).Error)
	}

	require.NoError(t, svc.DeleteScanResultsByImageIDs(ctx, []string{"sha256:img1", "sha256:img3"}))

	var remaining []models.VulnerabilityScanRecord
	require.NoError(t, db.Find(&remaining).Error)
	require.Len(t, remaining, 1)
	require.Equal(t, "sha256:img2", remaining[0].ID)
}

func TestVulnerabilityService_DeleteScanResultsByImageIDs_EmptyInput(t *testing.T) {
	ctx := context.Background()
	db := setupVulnerabilityScanTestDB(t)
	svc := &VulnerabilityService{db: db}

	require.NoError(t, svc.DeleteScanResultsByImageIDs(ctx, nil))
	require.NoError(t, svc.DeleteScanResultsByImageIDs(ctx, []string{}))
}

func TestSeverityCountColumnsForFilterInternal(t *testing.T) {
	tests := []struct {
		name    string
		value   string
		want    []string
		wantNil bool
	}{
		{
			name:  "single severity",
			value: "critical",
			want:  []string{"critical_count"},
		},
		{
			name:  "multiple severities and duplicates",
			value: "high,critical,high,UNKNOWN",
			want:  []string{"high_count", "critical_count", "unknown_count"},
		},
		{
			name:  "invalid severities only",
			value: "foo,bar",
			want:  []string{},
		},
		{
			name:    "empty value",
			value:   " , , ",
			wantNil: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := severityCountColumnsForFilterInternal(tt.value)
			if tt.wantNil {
				require.Nil(t, got)
				return
			}
			require.Equal(t, tt.want, got)
		})
	}
}

func TestApplyListAllVulnerabilityRecordPrefiltersInternal_NoPossibleMatches(t *testing.T) {
	db := setupVulnerabilityScanTestDB(t)
	base := db.WithContext(context.Background()).Model(&models.VulnerabilityScanRecord{})

	_, ok := applyListAllVulnerabilityRecordPrefiltersInternal(base, map[string]string{"severity": "not-a-severity"})
	require.False(t, ok)

	_, ok = applyListAllVulnerabilityRecordPrefiltersInternal(base, map[string]string{"imageName": "  ,  "})
	require.False(t, ok)

	_, ok = applyListAllVulnerabilityRecordPrefiltersInternal(base, map[string]string{
		"severity":  "high,bad",
		"imageName": "nginx",
	})
	require.True(t, ok)
}

func TestEstimatedVulnerabilityRecordCountInternal(t *testing.T) {
	records := []models.VulnerabilityScanRecord{
		{TotalCount: 5},
		{TotalCount: 0},
		{TotalCount: -3},
		{TotalCount: 12},
	}

	require.Equal(t, 17, estimatedVulnerabilityRecordCountInternal(records))
}

func TestVulnerabilityService_ListAllVulnerabilities_FiltersIgnoredInline(t *testing.T) {
	ctx := context.Background()
	db := setupVulnerabilityScanTestDB(t)
	svc := &VulnerabilityService{db: db}

	vulns := []vulnerability.Vulnerability{
		{
			VulnerabilityID:  "CVE-2026-0001",
			PkgName:          "openssl",
			InstalledVersion: "1.0.0",
			Severity:         vulnerability.SeverityHigh,
		},
	}
	rawVulns, err := json.Marshal(vulns)
	require.NoError(t, err)

	scan := models.VulnerabilityScanRecord{
		ID:              "sha256:list-all-1",
		ImageName:       "nginx:latest",
		Status:          models.ScanStatusCompleted,
		ScanTime:        time.Now(),
		HighCount:       1,
		TotalCount:      1,
		Vulnerabilities: models.StringSlice{string(rawVulns)},
	}
	require.NoError(t, db.Create(&scan).Error)

	reason := "accepted risk"
	ignore := models.VulnerabilityIgnore{
		EnvironmentID:    "env-1",
		ImageID:          scan.ID,
		VulnerabilityID:  "CVE-2026-0001",
		PkgName:          "openssl",
		InstalledVersion: "1.0.0",
		Reason:           &reason,
		CreatedBy:        "tester",
	}
	require.NoError(t, db.Create(&ignore).Error)

	items, page, err := svc.ListAllVulnerabilities(ctx, "env-1", pagination.QueryParams{
		PaginationParams: pagination.PaginationParams{Start: 0, Limit: 20},
	})
	require.NoError(t, err)
	require.Empty(t, items)
	require.Equal(t, int64(0), page.TotalItems)
	require.Equal(t, int64(0), page.GrandTotalItems)
}
