package services

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"strings"
	"sync"
	"time"

	containertypes "github.com/docker/docker/api/types/container"
	imagetypes "github.com/docker/docker/api/types/image"
	mounttypes "github.com/docker/docker/api/types/mount"
	volumetypes "github.com/docker/docker/api/types/volume"
	"github.com/docker/docker/pkg/stdcopy"
	"github.com/getarcaneapp/arcane/backend/internal/database"
	"github.com/getarcaneapp/arcane/backend/internal/models"
	"github.com/getarcaneapp/arcane/backend/internal/utils/pagination"
	"github.com/getarcaneapp/arcane/backend/internal/utils/timeouts"
	"github.com/getarcaneapp/arcane/backend/pkg/libarcane"
	"github.com/getarcaneapp/arcane/types/vulnerability"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

const (
	DefaultTrivyImage     = "aquasecurity/trivy:latest"
	trivyCacheVolumeName  = "arcane-trivy-cache"
	trivyCacheMountTarget = "/root/.cache"
)

// VulnerabilityService handles vulnerability scanning of container images
type VulnerabilityService struct {
	db              *database.DB
	dockerService   *DockerClientService
	eventService    *EventService
	settingsService *SettingsService
	// scanLocks provides per-image locking to allow concurrent scans of different images
	// while preventing duplicate scans of the same image
	scanLocks sync.Map // map[string]*sync.Mutex
}

// getImageLock returns a mutex for the given image ID, creating one if needed
func (s *VulnerabilityService) getImageLock(imageID string) *sync.Mutex {
	lock, _ := s.scanLocks.LoadOrStore(imageID, &sync.Mutex{})
	return lock.(*sync.Mutex)
}

// NewVulnerabilityService creates a new VulnerabilityService instance
func NewVulnerabilityService(db *database.DB, dockerService *DockerClientService, eventService *EventService, settingsService *SettingsService) *VulnerabilityService {
	return &VulnerabilityService{
		db:              db,
		dockerService:   dockerService,
		eventService:    eventService,
		settingsService: settingsService,
	}
}

// ScanImage scans an image for vulnerabilities using Trivy
func (s *VulnerabilityService) ScanImage(ctx context.Context, imageID string, user models.User) (*vulnerability.ScanResult, error) {
	// Get Docker client to inspect the image
	dockerClient, err := s.dockerService.GetClient()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to Docker: %w", err)
	}

	// Inspect the image to get details
	imageInspect, err := dockerClient.ImageInspect(ctx, imageID)
	if err != nil {
		return nil, fmt.Errorf("failed to inspect image: %w", err)
	}

	// Determine image name to scan
	imageName := imageID
	if len(imageInspect.RepoTags) > 0 {
		imageName = imageInspect.RepoTags[0]
	} else if len(imageInspect.RepoDigests) > 0 {
		imageName = imageInspect.RepoDigests[0]
	}

	trivyImage, err := s.ensureTrivyImageInternal(ctx)
	if err != nil {
		result := &vulnerability.ScanResult{
			ImageID:   imageID,
			ImageName: imageName,
			ScanTime:  time.Now(),
			Status:    vulnerability.ScanStatusFailed,
			Error:     fmt.Sprintf("Trivy scanner is not available: %s", err.Error()),
		}
		if saveErr := s.saveScanResult(ctx, result); saveErr != nil {
			slog.WarnContext(ctx, "failed to save scan result", "error", saveErr)
		}
		return result, nil
	}

	// Create pending scan record
	pendingResult := &vulnerability.ScanResult{
		ImageID:   imageID,
		ImageName: imageName,
		ScanTime:  time.Now(),
		Status:    vulnerability.ScanStatusScanning,
	}
	if saveErr := s.saveScanResult(ctx, pendingResult); saveErr != nil {
		slog.WarnContext(ctx, "failed to save pending scan result", "error", saveErr)
	}

	// Run the scan
	startTime := time.Now()
	result, err := s.runTrivyScan(ctx, trivyImage, imageName, imageID)
	duration := time.Since(startTime).Milliseconds()

	if err != nil {
		failedResult := &vulnerability.ScanResult{
			ImageID:   imageID,
			ImageName: imageName,
			ScanTime:  time.Now(),
			Status:    vulnerability.ScanStatusFailed,
			Error:     err.Error(),
			Duration:  duration,
		}
		if saveErr := s.saveScanResult(ctx, failedResult); saveErr != nil {
			slog.WarnContext(ctx, "failed to save failed scan result", "error", saveErr)
		}
		s.logScanEvent(ctx, imageID, imageName, user, false, err.Error())
		return failedResult, nil
	}

	result.Duration = duration
	s.ensureSummary(result)
	if saveErr := s.saveScanResult(ctx, result); saveErr != nil {
		slog.WarnContext(ctx, "failed to save scan result", "error", saveErr)
	}

	s.logScanEvent(ctx, imageID, imageName, user, true, "")
	return result, nil
}

// GetScanResult retrieves the most recent scan result for an image
func (s *VulnerabilityService) GetScanResult(ctx context.Context, imageID string) (*vulnerability.ScanResult, error) {
	if s.db == nil {
		return nil, nil
	}

	var record models.VulnerabilityScanRecord
	err := s.db.WithContext(ctx).Where("id = ?", imageID).First(&record).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to get scan result: %w", err)
	}

	return s.convertRecordToResult(&record)
}

// GetScanSummary retrieves just the summary for an image (for list views)
func (s *VulnerabilityService) GetScanSummary(ctx context.Context, imageID string) (*vulnerability.ScanSummary, error) {
	if s.db == nil {
		return nil, nil
	}

	var record models.VulnerabilityScanRecord
	err := s.db.WithContext(ctx).
		Select("id", "scan_time", "status", "critical_count", "high_count", "medium_count", "low_count", "unknown_count", "total_count", "error").
		Where("id = ?", imageID).
		First(&record).Error

	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to get scan summary: %w", err)
	}

	var errPtr *string
	if record.Error != nil {
		errPtr = record.Error
	}

	return &vulnerability.ScanSummary{
		ImageID:  record.ID,
		ScanTime: record.ScanTime,
		Status:   vulnerability.ScanStatus(record.Status),
		Summary: &vulnerability.SeveritySummary{
			Critical: record.CriticalCount,
			High:     record.HighCount,
			Medium:   record.MediumCount,
			Low:      record.LowCount,
			Unknown:  record.UnknownCount,
			Total:    record.TotalCount,
		},
		Error: stringPtrValueOrEmptyInternal(errPtr),
	}, nil
}

// ListVulnerabilities returns a paginated, filtered list of vulnerabilities for an image.
func (s *VulnerabilityService) ListVulnerabilities(ctx context.Context, imageID string, params pagination.QueryParams) ([]vulnerability.Vulnerability, pagination.Response, error) {
	result, err := s.GetScanResult(ctx, imageID)
	if err != nil {
		return nil, pagination.Response{}, fmt.Errorf("failed to get scan result: %w", err)
	}
	if result == nil {
		limit := params.Limit
		if limit <= 0 {
			limit = 20
		}
		return []vulnerability.Vulnerability{}, pagination.Response{
			TotalPages:      1,
			TotalItems:      0,
			CurrentPage:     1,
			ItemsPerPage:    limit,
			GrandTotalItems: 0,
		}, nil
	}

	config := pagination.Config[vulnerability.Vulnerability]{
		SearchAccessors: []pagination.SearchAccessor[vulnerability.Vulnerability]{
			func(item vulnerability.Vulnerability) (string, error) { return item.VulnerabilityID, nil },
			func(item vulnerability.Vulnerability) (string, error) { return item.PkgName, nil },
			func(item vulnerability.Vulnerability) (string, error) { return item.InstalledVersion, nil },
			func(item vulnerability.Vulnerability) (string, error) { return item.FixedVersion, nil },
			func(item vulnerability.Vulnerability) (string, error) { return item.Title, nil },
		},
		SortBindings: []pagination.SortBinding[vulnerability.Vulnerability]{
			{
				Key: "vulnerabilityId",
				Fn: func(a, b vulnerability.Vulnerability) int {
					return strings.Compare(a.VulnerabilityID, b.VulnerabilityID)
				},
			},
			{
				Key: "pkgName",
				Fn:  func(a, b vulnerability.Vulnerability) int { return strings.Compare(a.PkgName, b.PkgName) },
			},
			{
				Key: "severity",
				Fn: func(a, b vulnerability.Vulnerability) int {
					return severityRankInternal(a.Severity) - severityRankInternal(b.Severity)
				},
			},
			{
				Key: "installedVersion",
				Fn: func(a, b vulnerability.Vulnerability) int {
					return strings.Compare(a.InstalledVersion, b.InstalledVersion)
				},
			},
			{
				Key: "fixedVersion",
				Fn:  func(a, b vulnerability.Vulnerability) int { return strings.Compare(a.FixedVersion, b.FixedVersion) },
			},
		},
		FilterAccessors: []pagination.FilterAccessor[vulnerability.Vulnerability]{
			{
				Key: "severity",
				Fn: func(item vulnerability.Vulnerability, value string) bool {
					return strings.EqualFold(string(item.Severity), value)
				},
			},
		},
	}

	filtered := pagination.SearchOrderAndPaginate(result.Vulnerabilities, params, config)
	response := pagination.BuildResponseFromFilterResult(filtered, params)

	return filtered.Items, response, nil
}

// GetEnvironmentSummary returns aggregated vulnerability counts across all images.
func (s *VulnerabilityService) GetEnvironmentSummary(ctx context.Context) (*vulnerability.EnvironmentVulnerabilitySummary, error) {
	summary := &vulnerability.EnvironmentVulnerabilitySummary{
		Summary: &vulnerability.SeveritySummary{},
	}

	if s.dockerService != nil {
		_, _, _, total, err := s.dockerService.GetAllImages(ctx)
		if err != nil {
			slog.WarnContext(ctx, "failed to list images for vulnerability summary", "error", err)
		} else {
			summary.TotalImages = total
		}
	}

	if s.db == nil {
		return summary, nil
	}

	type aggregate struct {
		Critical int `gorm:"column:critical"`
		High     int `gorm:"column:high"`
		Medium   int `gorm:"column:medium"`
		Low      int `gorm:"column:low"`
		Unknown  int `gorm:"column:unknown"`
		Total    int `gorm:"column:total"`
		Scanned  int `gorm:"column:scanned"`
	}

	var agg aggregate
	err := s.db.WithContext(ctx).
		Model(&models.VulnerabilityScanRecord{}).
		Select(
			"COALESCE(SUM(critical_count), 0) AS critical",
			"COALESCE(SUM(high_count), 0) AS high",
			"COALESCE(SUM(medium_count), 0) AS medium",
			"COALESCE(SUM(low_count), 0) AS low",
			"COALESCE(SUM(unknown_count), 0) AS unknown",
			"COALESCE(SUM(total_count), 0) AS total",
			"COUNT(*) AS scanned",
		).
		Where("status = ?", models.ScanStatusCompleted).
		Scan(&agg).Error
	if err != nil {
		return nil, fmt.Errorf("failed to aggregate vulnerability summary: %w", err)
	}

	summary.ScannedImages = agg.Scanned
	summary.Summary = &vulnerability.SeveritySummary{
		Critical: agg.Critical,
		High:     agg.High,
		Medium:   agg.Medium,
		Low:      agg.Low,
		Unknown:  agg.Unknown,
		Total:    agg.Total,
	}

	return summary, nil
}

// ListAllVulnerabilities returns a paginated list of vulnerabilities across all scanned images.
func (s *VulnerabilityService) ListAllVulnerabilities(ctx context.Context, params pagination.QueryParams) ([]vulnerability.VulnerabilityWithImage, pagination.Response, error) {
	if params.Limit == 0 {
		params.Limit = 20
	}

	if s.db == nil {
		return []vulnerability.VulnerabilityWithImage{}, pagination.Response{
			TotalPages:      1,
			TotalItems:      0,
			CurrentPage:     1,
			ItemsPerPage:    params.Limit,
			GrandTotalItems: 0,
		}, nil
	}

	var records []models.VulnerabilityScanRecord
	if err := s.db.WithContext(ctx).
		Select("id", "image_name", "vulnerabilities", "status", "total_count").
		Where("status = ?", models.ScanStatusCompleted).
		Where("total_count > 0").
		Find(&records).Error; err != nil {
		return nil, pagination.Response{}, fmt.Errorf("failed to list vulnerability scans: %w", err)
	}

	items := make([]vulnerability.VulnerabilityWithImage, 0)
	for _, record := range records {
		if len(record.Vulnerabilities) == 0 || record.Vulnerabilities[0] == "" {
			continue
		}

		var vulns []vulnerability.Vulnerability
		if err := json.Unmarshal([]byte(record.Vulnerabilities[0]), &vulns); err != nil {
			slog.WarnContext(ctx, "failed to unmarshal vulnerabilities", "error", err, "image_id", record.ID)
			continue
		}

		for _, vuln := range vulns {
			items = append(items, vulnerability.VulnerabilityWithImage{
				Vulnerability: vuln,
				ImageID:       record.ID,
				ImageName:     record.ImageName,
			})
		}
	}

	config := pagination.Config[vulnerability.VulnerabilityWithImage]{
		SearchAccessors: []pagination.SearchAccessor[vulnerability.VulnerabilityWithImage]{
			func(item vulnerability.VulnerabilityWithImage) (string, error) { return item.VulnerabilityID, nil },
			func(item vulnerability.VulnerabilityWithImage) (string, error) { return item.PkgName, nil },
			func(item vulnerability.VulnerabilityWithImage) (string, error) { return item.InstalledVersion, nil },
			func(item vulnerability.VulnerabilityWithImage) (string, error) { return item.FixedVersion, nil },
			func(item vulnerability.VulnerabilityWithImage) (string, error) { return item.Title, nil },
			func(item vulnerability.VulnerabilityWithImage) (string, error) { return item.ImageName, nil },
			func(item vulnerability.VulnerabilityWithImage) (string, error) { return item.ImageID, nil },
		},
		SortBindings: []pagination.SortBinding[vulnerability.VulnerabilityWithImage]{
			{
				Key: "vulnerabilityId",
				Fn: func(a, b vulnerability.VulnerabilityWithImage) int {
					return strings.Compare(a.VulnerabilityID, b.VulnerabilityID)
				},
			},
			{
				Key: "pkgName",
				Fn:  func(a, b vulnerability.VulnerabilityWithImage) int { return strings.Compare(a.PkgName, b.PkgName) },
			},
			{
				Key: "severity",
				Fn: func(a, b vulnerability.VulnerabilityWithImage) int {
					return severityRankInternal(a.Severity) - severityRankInternal(b.Severity)
				},
			},
			{
				Key: "installedVersion",
				Fn: func(a, b vulnerability.VulnerabilityWithImage) int {
					return strings.Compare(a.InstalledVersion, b.InstalledVersion)
				},
			},
			{
				Key: "fixedVersion",
				Fn: func(a, b vulnerability.VulnerabilityWithImage) int {
					return strings.Compare(a.FixedVersion, b.FixedVersion)
				},
			},
			{
				Key: "imageName",
				Fn:  func(a, b vulnerability.VulnerabilityWithImage) int { return strings.Compare(a.ImageName, b.ImageName) },
			},
		},
		FilterAccessors: []pagination.FilterAccessor[vulnerability.VulnerabilityWithImage]{
			{
				Key: "severity",
				Fn: func(item vulnerability.VulnerabilityWithImage, value string) bool {
					return strings.EqualFold(string(item.Severity), value)
				},
			},
		},
	}

	filtered := pagination.SearchOrderAndPaginate(items, params, config)
	response := pagination.BuildResponseFromFilterResult(filtered, params)

	return filtered.Items, response, nil
}

func severityRankInternal(severity vulnerability.Severity) int {
	switch severity {
	case vulnerability.SeverityCritical:
		return 4
	case vulnerability.SeverityHigh:
		return 3
	case vulnerability.SeverityMedium:
		return 2
	case vulnerability.SeverityLow:
		return 1
	case vulnerability.SeverityUnknown:
		return 0
	default:
		return 0
	}
}

// GetScanSummariesByImageIDs retrieves scan summaries for multiple images
func (s *VulnerabilityService) GetScanSummariesByImageIDs(ctx context.Context, imageIDs []string) (map[string]*vulnerability.ScanSummary, error) {
	if s.db == nil || len(imageIDs) == 0 {
		return make(map[string]*vulnerability.ScanSummary), nil
	}

	var records []models.VulnerabilityScanRecord
	err := s.db.WithContext(ctx).
		Select("id", "scan_time", "status", "critical_count", "high_count", "medium_count", "low_count", "unknown_count", "total_count", "error").
		Where("id IN ?", imageIDs).
		Find(&records).Error

	if err != nil {
		return nil, fmt.Errorf("failed to get scan summaries: %w", err)
	}

	result := make(map[string]*vulnerability.ScanSummary, len(records))
	for _, record := range records {
		var errStr string
		if record.Error != nil {
			errStr = *record.Error
		}

		result[record.ID] = &vulnerability.ScanSummary{
			ImageID:  record.ID,
			ScanTime: record.ScanTime,
			Status:   vulnerability.ScanStatus(record.Status),
			Summary: &vulnerability.SeveritySummary{
				Critical: record.CriticalCount,
				High:     record.HighCount,
				Medium:   record.MediumCount,
				Low:      record.LowCount,
				Unknown:  record.UnknownCount,
				Total:    record.TotalCount,
			},
			Error: errStr,
		}
	}

	return result, nil
}

// DeleteScanResult deletes the scan result for an image
func (s *VulnerabilityService) DeleteScanResult(ctx context.Context, imageID string) error {
	if s.db == nil {
		return nil
	}

	return s.db.WithContext(ctx).Where("id = ?", imageID).Delete(&models.VulnerabilityScanRecord{}).Error
}

// GetTrivyVersion returns the Trivy version from the Trivy container image
func (s *VulnerabilityService) GetTrivyVersion(ctx context.Context) string {
	dockerClient, err := s.dockerService.GetClient()
	if err != nil {
		return ""
	}

	trivyImage, err := s.ensureTrivyImageInternal(ctx)
	if err != nil {
		return ""
	}

	config := &containertypes.Config{
		Image: trivyImage,
		Cmd:   []string{"--version"},
		Labels: map[string]string{
			libarcane.InternalContainerLabel: "true",
		},
	}

	hostConfig := &containertypes.HostConfig{
		AutoRemove: true,
	}

	resp, err := dockerClient.ContainerCreate(ctx, config, hostConfig, nil, nil, "")
	if err != nil {
		return ""
	}

	if err := dockerClient.ContainerStart(ctx, resp.ID, containertypes.StartOptions{}); err != nil {
		_ = dockerClient.ContainerRemove(ctx, resp.ID, containertypes.RemoveOptions{Force: true})
		return ""
	}

	logs, err := dockerClient.ContainerLogs(ctx, resp.ID, containertypes.LogsOptions{
		ShowStdout: true,
		ShowStderr: true,
		Follow:     true,
	})
	if err != nil {
		_ = dockerClient.ContainerRemove(ctx, resp.ID, containertypes.RemoveOptions{Force: true})
		return ""
	}
	defer logs.Close()

	var stdout bytes.Buffer
	logDone := make(chan error, 1)
	go func() {
		_, err := stdcopy.StdCopy(&stdout, io.Discard, logs)
		logDone <- err
	}()

	statusCh, errCh := dockerClient.ContainerWait(ctx, resp.ID, containertypes.WaitConditionNotRunning)
	var waitResp containertypes.WaitResponse
	select {
	case err := <-errCh:
		if err != nil {
			return ""
		}
	case waitResp = <-statusCh:
	}

	logs.Close()
	if err := <-logDone; err != nil && !errors.Is(err, io.EOF) {
		return ""
	}

	if waitResp.StatusCode != 0 {
		return ""
	}

	return parseTrivyVersion(stdout.String())
}

func parseTrivyVersion(output string) string {
	output = strings.TrimSpace(output)
	if output == "" {
		return ""
	}
	lines := strings.Split(output, "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "Version:") {
			return strings.TrimSpace(strings.TrimPrefix(line, "Version:"))
		}
	}
	return strings.TrimSpace(output)
}

func (s *VulnerabilityService) getTrivyImageRef() string {
	if s.settingsService == nil {
		return DefaultTrivyImage
	}

	cfg := s.settingsService.GetSettingsConfig()
	if cfg == nil {
		return DefaultTrivyImage
	}

	override := strings.TrimSpace(cfg.TrivyImage.Value)
	if override == "" {
		return DefaultTrivyImage
	}

	return override
}

func (s *VulnerabilityService) ensureTrivyImageInternal(ctx context.Context) (string, error) {
	dockerClient, err := s.dockerService.GetClient()
	if err != nil {
		return "", fmt.Errorf("failed to connect to Docker: %w", err)
	}

	trivyImage := s.getTrivyImageRef()
	if _, err := dockerClient.ImageInspect(ctx, trivyImage); err == nil {
		return trivyImage, nil
	}

	pullTimeoutSeconds := 0
	if s.settingsService != nil && s.settingsService.GetSettingsConfig() != nil {
		pullTimeoutSeconds = s.settingsService.GetSettingsConfig().DockerImagePullTimeout.AsInt()
	}

	pullCtx, pullCancel := timeouts.WithTimeout(ctx, pullTimeoutSeconds, timeouts.DefaultDockerImagePull)
	defer pullCancel()

	pullReader, err := dockerClient.ImagePull(pullCtx, trivyImage, imagetypes.PullOptions{})
	if err != nil {
		if errors.Is(pullCtx.Err(), context.DeadlineExceeded) {
			return "", fmt.Errorf("trivy image pull timed out for %s (increase DOCKER_IMAGE_PULL_TIMEOUT or setting)", trivyImage)
		}
		return "", fmt.Errorf("pull trivy image %s: %w", trivyImage, err)
	}
	_, _ = io.Copy(io.Discard, pullReader)
	_ = pullReader.Close()

	return trivyImage, nil
}

func (s *VulnerabilityService) ensureTrivyCacheVolumeInternal(ctx context.Context) (string, error) {
	dockerClient, err := s.dockerService.GetClient()
	if err != nil {
		return "", err
	}

	if _, err := dockerClient.VolumeInspect(ctx, trivyCacheVolumeName); err == nil {
		return trivyCacheVolumeName, nil
	}

	_, err = dockerClient.VolumeCreate(ctx, volumetypes.CreateOptions{
		Name: trivyCacheVolumeName,
		Labels: map[string]string{
			libarcane.InternalContainerLabel: "true",
		},
	})
	if err != nil {
		return "", fmt.Errorf("failed to create trivy cache volume: %w", err)
	}

	return trivyCacheVolumeName, nil
}

// runTrivyScan executes Trivy scan on an image
func (s *VulnerabilityService) runTrivyScan(ctx context.Context, trivyImage string, imageName string, imageID string) (*vulnerability.ScanResult, error) {
	// Use per-image locking to allow concurrent scans of different images
	lock := s.getImageLock(imageID)
	lock.Lock()
	defer lock.Unlock()

	dockerClient, err := s.dockerService.GetClient()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to Docker: %w", err)
	}

	cacheVolume, err := s.ensureTrivyCacheVolumeInternal(ctx)
	if err != nil {
		return nil, err
	}

	config := &containertypes.Config{
		Image: trivyImage,
		Cmd:   []string{"image", "--format", "json", "--quiet", imageName},
		Labels: map[string]string{
			libarcane.InternalContainerLabel: "true",
		},
	}

	hostConfig := &containertypes.HostConfig{
		AutoRemove: true,
		Mounts: []mounttypes.Mount{
			{
				Type:   mounttypes.TypeBind,
				Source: "/var/run/docker.sock",
				Target: "/var/run/docker.sock",
			},
			{
				Type:   mounttypes.TypeVolume,
				Source: cacheVolume,
				Target: trivyCacheMountTarget,
			},
		},
	}

	resp, err := dockerClient.ContainerCreate(ctx, config, hostConfig, nil, nil, "")
	if err != nil {
		return nil, fmt.Errorf("failed to create trivy container: %w", err)
	}

	if err := dockerClient.ContainerStart(ctx, resp.ID, containertypes.StartOptions{}); err != nil {
		_ = dockerClient.ContainerRemove(ctx, resp.ID, containertypes.RemoveOptions{Force: true})
		return nil, fmt.Errorf("failed to start trivy container: %w", err)
	}

	logs, err := dockerClient.ContainerLogs(ctx, resp.ID, containertypes.LogsOptions{
		ShowStdout: true,
		ShowStderr: true,
		Follow:     true,
	})
	if err != nil {
		_ = dockerClient.ContainerRemove(ctx, resp.ID, containertypes.RemoveOptions{Force: true})
		return nil, fmt.Errorf("failed to stream trivy logs: %w", err)
	}
	defer logs.Close()

	var stdout, stderr bytes.Buffer
	logDone := make(chan error, 1)
	go func() {
		_, err := stdcopy.StdCopy(&stdout, &stderr, logs)
		logDone <- err
	}()

	startTime := time.Now()
	statusCh, errCh := dockerClient.ContainerWait(ctx, resp.ID, containertypes.WaitConditionNotRunning)
	var waitResp containertypes.WaitResponse
	select {
	case err := <-errCh:
		if err != nil {
			if ctx.Err() != nil {
				cleanupCtx, cleanupCancel := timeouts.WithTimeout(ctx, 0, timeouts.DefaultDockerAPI)
				defer cleanupCancel()
				_ = dockerClient.ContainerRemove(cleanupCtx, resp.ID, containertypes.RemoveOptions{Force: true})
				return nil, fmt.Errorf("scan cancelled: %w", ctx.Err())
			}
			return nil, fmt.Errorf("trivy container wait failed: %w", err)
		}
	case waitResp = <-statusCh:
	}

	logs.Close()
	if err := <-logDone; err != nil && !errors.Is(err, io.EOF) {
		return nil, fmt.Errorf("failed to read trivy logs: %w", err)
	}

	duration := time.Since(startTime).Milliseconds()

	if waitResp.StatusCode != 0 {
		errMsg := strings.TrimSpace(stderr.String())
		if errMsg == "" {
			errMsg = strings.TrimSpace(stdout.String())
		}
		if errMsg == "" {
			errMsg = fmt.Sprintf("exit status %d", waitResp.StatusCode)
		}
		return nil, fmt.Errorf("trivy scan failed: %s", errMsg)
	}

	output := bytes.TrimSpace(stdout.Bytes())
	if len(output) == 0 {
		errMsg := strings.TrimSpace(stderr.String())
		if errMsg == "" {
			errMsg = "trivy scan produced no output"
		}
		return nil, fmt.Errorf("trivy scan failed: %s", errMsg)
	}

	// Parse Trivy JSON output
	var trivyReport vulnerability.TrivyReport
	if err := json.Unmarshal(output, &trivyReport); err != nil {
		return nil, fmt.Errorf("failed to parse trivy output: %w", err)
	}

	// Convert Trivy report to our ScanResult format
	result := vulnerability.ConvertTrivyReportToScanResult(&trivyReport, imageID, time.Now(), duration)
	result.ScannerVersion = s.GetTrivyVersion(ctx)

	return result, nil
}

// saveScanResult saves the scan result to the database
func (s *VulnerabilityService) saveScanResult(ctx context.Context, result *vulnerability.ScanResult) error {
	if s.db == nil {
		return nil
	}

	s.ensureSummary(result)

	// Convert vulnerabilities to JSON
	var vulnJSON models.StringSlice
	if len(result.Vulnerabilities) > 0 {
		vulnBytes, err := json.Marshal(result.Vulnerabilities)
		if err != nil {
			return fmt.Errorf("failed to marshal vulnerabilities: %w", err)
		}
		vulnJSON = models.StringSlice{string(vulnBytes)}
	}

	var errPtr *string
	if result.Error != "" {
		errPtr = &result.Error
	}

	var summary *vulnerability.SeveritySummary
	if result.Summary != nil {
		summary = result.Summary
	} else {
		summary = &vulnerability.SeveritySummary{}
	}

	record := models.VulnerabilityScanRecord{
		ID:              result.ImageID,
		ImageName:       result.ImageName,
		Status:          string(result.Status),
		ScanTime:        result.ScanTime,
		Duration:        result.Duration,
		CriticalCount:   summary.Critical,
		HighCount:       summary.High,
		MediumCount:     summary.Medium,
		LowCount:        summary.Low,
		UnknownCount:    summary.Unknown,
		TotalCount:      summary.Total,
		Vulnerabilities: vulnJSON,
		Error:           errPtr,
		ScannerVersion:  result.ScannerVersion,
	}

	// Upsert the record
	return s.db.WithContext(ctx).Clauses(clause.OnConflict{
		Columns:   []clause.Column{{Name: "id"}},
		UpdateAll: true,
	}).Create(&record).Error
}

// convertRecordToResult converts a database record to a ScanResult
func (s *VulnerabilityService) convertRecordToResult(record *models.VulnerabilityScanRecord) (*vulnerability.ScanResult, error) {
	result := &vulnerability.ScanResult{
		ImageID:   record.ID,
		ImageName: record.ImageName,
		ScanTime:  record.ScanTime,
		Status:    vulnerability.ScanStatus(record.Status),
		Duration:  record.Duration,
		Summary: &vulnerability.SeveritySummary{
			Critical: record.CriticalCount,
			High:     record.HighCount,
			Medium:   record.MediumCount,
			Low:      record.LowCount,
			Unknown:  record.UnknownCount,
			Total:    record.TotalCount,
		},
		ScannerVersion: record.ScannerVersion,
	}

	if record.Error != nil {
		result.Error = *record.Error
	}

	// Parse vulnerabilities from JSON
	if len(record.Vulnerabilities) > 0 && record.Vulnerabilities[0] != "" {
		var vulns []vulnerability.Vulnerability
		if err := json.Unmarshal([]byte(record.Vulnerabilities[0]), &vulns); err != nil {
			slog.Warn("failed to unmarshal vulnerabilities", "error", err)
		} else {
			result.Vulnerabilities = vulns
		}
	}

	s.ensureSummary(result)

	return result, nil
}

func (s *VulnerabilityService) ensureSummary(result *vulnerability.ScanResult) {
	if result == nil {
		return
	}

	if len(result.Vulnerabilities) == 0 {
		if result.Summary == nil {
			result.Summary = &vulnerability.SeveritySummary{}
		}
		return
	}

	if result.Summary != nil && result.Summary.Total > 0 {
		return
	}

	result.Summary = buildSeveritySummaryFromVulnerabilitiesInternal(result.Vulnerabilities)
}

func buildSeveritySummaryFromVulnerabilitiesInternal(vulns []vulnerability.Vulnerability) *vulnerability.SeveritySummary {
	summary := &vulnerability.SeveritySummary{}
	for _, vuln := range vulns {
		switch vuln.Severity {
		case vulnerability.SeverityCritical:
			summary.Critical++
		case vulnerability.SeverityHigh:
			summary.High++
		case vulnerability.SeverityMedium:
			summary.Medium++
		case vulnerability.SeverityLow:
			summary.Low++
		case vulnerability.SeverityUnknown:
			summary.Unknown++
		default:
			summary.Unknown++
		}
		summary.Total++
	}
	return summary
}

// logScanEvent logs a vulnerability scan event
func (s *VulnerabilityService) logScanEvent(ctx context.Context, imageID, imageName string, user models.User, success bool, errMsg string) {
	metadata := models.JSON{
		"action":    "vulnerability_scan",
		"imageId":   imageID,
		"imageName": imageName,
		"success":   success,
	}
	if errMsg != "" {
		metadata["error"] = errMsg
	}

	eventType := models.EventTypeImageScan
	if err := s.eventService.LogImageEvent(ctx, eventType, imageID, imageName, user.ID, user.Username, "0", metadata); err != nil {
		slog.WarnContext(ctx, "failed to log vulnerability scan event", "error", err)
	}
}

// stringPtrValueOrEmptyInternal returns the string value from a pointer or empty string if nil
func stringPtrValueOrEmptyInternal(p *string) string {
	if p == nil {
		return ""
	}
	return *p
}
