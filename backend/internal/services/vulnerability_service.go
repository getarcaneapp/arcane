package services

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os/exec"
	"strings"
	"sync"
	"time"

	"github.com/getarcaneapp/arcane/backend/internal/database"
	"github.com/getarcaneapp/arcane/backend/internal/models"
	"github.com/getarcaneapp/arcane/backend/internal/utils/pagination"
	"github.com/getarcaneapp/arcane/types/vulnerability"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

// VulnerabilityService handles vulnerability scanning of container images
type VulnerabilityService struct {
	db            *database.DB
	dockerService *DockerClientService
	eventService  *EventService
	// scanLocks provides per-image locking to allow concurrent scans of different images
	// while preventing duplicate scans of the same image
	scanLocks sync.Map // map[string]*sync.Mutex
}

// getImageLock returns a mutex for the given image ID, creating one if needed
func (s *VulnerabilityService) getImageLock(imageID string) *sync.Mutex {
	lock, _ := s.scanLocks.LoadOrStore(imageID, &sync.Mutex{})
	return lock.(*sync.Mutex)
}

// NewVulnerabilityService creates a new VulnerabilityService instance
func NewVulnerabilityService(db *database.DB, dockerService *DockerClientService, eventService *EventService) *VulnerabilityService {
	return &VulnerabilityService{
		db:            db,
		dockerService: dockerService,
		eventService:  eventService,
	}
}

// ScanImage scans an image for vulnerabilities using Trivy
func (s *VulnerabilityService) ScanImage(ctx context.Context, imageID string, user models.User) (*vulnerability.ScanResult, error) {
	// Get Docker client to inspect the image
	dockerClient, err := s.dockerService.GetClient()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to Docker: %w", err)
	}

	// Inspect the image to get details
	imageInspect, err := dockerClient.ImageInspect(ctx, imageID)
	if err != nil {
		return nil, fmt.Errorf("failed to inspect image: %w", err)
	}

	// Determine image name to scan
	imageName := imageID
	if len(imageInspect.RepoTags) > 0 {
		imageName = imageInspect.RepoTags[0]
	} else if len(imageInspect.RepoDigests) > 0 {
		imageName = imageInspect.RepoDigests[0]
	}

	// Check if Trivy is available
	if !s.isTrivyAvailable() {
		// Return a placeholder result indicating Trivy is not available
		result := &vulnerability.ScanResult{
			ImageID:   imageID,
			ImageName: imageName,
			ScanTime:  time.Now(),
			Status:    vulnerability.ScanStatusFailed,
			Error:     "Trivy scanner is not available. Please install Trivy to enable vulnerability scanning.",
		}
		if saveErr := s.saveScanResult(ctx, result); saveErr != nil {
			slog.WarnContext(ctx, "failed to save scan result", "error", saveErr)
		}
		return result, nil
	}

	// Create pending scan record
	pendingResult := &vulnerability.ScanResult{
		ImageID:   imageID,
		ImageName: imageName,
		ScanTime:  time.Now(),
		Status:    vulnerability.ScanStatusScanning,
	}
	if saveErr := s.saveScanResult(ctx, pendingResult); saveErr != nil {
		slog.WarnContext(ctx, "failed to save pending scan result", "error", saveErr)
	}

	// Run the scan
	startTime := time.Now()
	result, err := s.runTrivyScan(ctx, imageName, imageID)
	duration := time.Since(startTime).Milliseconds()

	if err != nil {
		failedResult := &vulnerability.ScanResult{
			ImageID:   imageID,
			ImageName: imageName,
			ScanTime:  time.Now(),
			Status:    vulnerability.ScanStatusFailed,
			Error:     err.Error(),
			Duration:  duration,
		}
		if saveErr := s.saveScanResult(ctx, failedResult); saveErr != nil {
			slog.WarnContext(ctx, "failed to save failed scan result", "error", saveErr)
		}
		s.logScanEvent(ctx, imageID, imageName, user, false, err.Error())
		return failedResult, nil
	}

	result.Duration = duration
	s.ensureSummary(result)
	if saveErr := s.saveScanResult(ctx, result); saveErr != nil {
		slog.WarnContext(ctx, "failed to save scan result", "error", saveErr)
	}

	s.logScanEvent(ctx, imageID, imageName, user, true, "")
	return result, nil
}

// GetScanResult retrieves the most recent scan result for an image
func (s *VulnerabilityService) GetScanResult(ctx context.Context, imageID string) (*vulnerability.ScanResult, error) {
	if s.db == nil {
		return nil, nil
	}

	var record models.VulnerabilityScanRecord
	err := s.db.WithContext(ctx).Where("id = ?", imageID).First(&record).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to get scan result: %w", err)
	}

	return s.convertRecordToResult(&record)
}

// GetScanSummary retrieves just the summary for an image (for list views)
func (s *VulnerabilityService) GetScanSummary(ctx context.Context, imageID string) (*vulnerability.ScanSummary, error) {
	if s.db == nil {
		return nil, nil
	}

	var record models.VulnerabilityScanRecord
	err := s.db.WithContext(ctx).
		Select("id", "scan_time", "status", "critical_count", "high_count", "medium_count", "low_count", "unknown_count", "total_count", "error").
		Where("id = ?", imageID).
		First(&record).Error

	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to get scan summary: %w", err)
	}

	var errPtr *string
	if record.Error != nil {
		errPtr = record.Error
	}

	return &vulnerability.ScanSummary{
		ImageID:  record.ID,
		ScanTime: record.ScanTime,
		Status:   vulnerability.ScanStatus(record.Status),
		Summary: &vulnerability.SeveritySummary{
			Critical: record.CriticalCount,
			High:     record.HighCount,
			Medium:   record.MediumCount,
			Low:      record.LowCount,
			Unknown:  record.UnknownCount,
			Total:    record.TotalCount,
		},
		Error: stringPtrValueOrEmpty(errPtr),
	}, nil
}

// ListVulnerabilities returns a paginated, filtered list of vulnerabilities for an image.
func (s *VulnerabilityService) ListVulnerabilities(ctx context.Context, imageID string, params pagination.QueryParams) ([]vulnerability.Vulnerability, pagination.Response, error) {
	result, err := s.GetScanResult(ctx, imageID)
	if err != nil {
		return nil, pagination.Response{}, fmt.Errorf("failed to get scan result: %w", err)
	}
	if result == nil {
		limit := params.Limit
		if limit <= 0 {
			limit = 20
		}
		return []vulnerability.Vulnerability{}, pagination.Response{
			TotalPages:      1,
			TotalItems:      0,
			CurrentPage:     1,
			ItemsPerPage:    limit,
			GrandTotalItems: 0,
		}, nil
	}

	config := pagination.Config[vulnerability.Vulnerability]{
		SearchAccessors: []pagination.SearchAccessor[vulnerability.Vulnerability]{
			func(item vulnerability.Vulnerability) (string, error) { return item.VulnerabilityID, nil },
			func(item vulnerability.Vulnerability) (string, error) { return item.PkgName, nil },
			func(item vulnerability.Vulnerability) (string, error) { return item.InstalledVersion, nil },
			func(item vulnerability.Vulnerability) (string, error) { return item.FixedVersion, nil },
			func(item vulnerability.Vulnerability) (string, error) { return item.Title, nil },
		},
		SortBindings: []pagination.SortBinding[vulnerability.Vulnerability]{
			{
				Key: "vulnerabilityId",
				Fn: func(a, b vulnerability.Vulnerability) int { return strings.Compare(a.VulnerabilityID, b.VulnerabilityID) },
			},
			{
				Key: "pkgName",
				Fn: func(a, b vulnerability.Vulnerability) int { return strings.Compare(a.PkgName, b.PkgName) },
			},
			{
				Key: "severity",
				Fn: func(a, b vulnerability.Vulnerability) int { return severityRank(a.Severity) - severityRank(b.Severity) },
			},
			{
				Key: "installedVersion",
				Fn: func(a, b vulnerability.Vulnerability) int { return strings.Compare(a.InstalledVersion, b.InstalledVersion) },
			},
			{
				Key: "fixedVersion",
				Fn: func(a, b vulnerability.Vulnerability) int { return strings.Compare(a.FixedVersion, b.FixedVersion) },
			},
		},
		FilterAccessors: []pagination.FilterAccessor[vulnerability.Vulnerability]{
			{
				Key: "severity",
				Fn: func(item vulnerability.Vulnerability, value string) bool {
					return strings.EqualFold(string(item.Severity), value)
				},
			},
		},
	}

	filtered := pagination.SearchOrderAndPaginate(result.Vulnerabilities, params, config)
	response := pagination.BuildResponseFromFilterResult(filtered, params)

	return filtered.Items, response, nil
}

func severityRank(severity vulnerability.Severity) int {
	switch severity {
	case vulnerability.SeverityCritical:
		return 4
	case vulnerability.SeverityHigh:
		return 3
	case vulnerability.SeverityMedium:
		return 2
	case vulnerability.SeverityLow:
		return 1
	default:
		return 0
	}
}

// GetScanSummariesByImageIDs retrieves scan summaries for multiple images
func (s *VulnerabilityService) GetScanSummariesByImageIDs(ctx context.Context, imageIDs []string) (map[string]*vulnerability.ScanSummary, error) {
	if s.db == nil || len(imageIDs) == 0 {
		return make(map[string]*vulnerability.ScanSummary), nil
	}

	var records []models.VulnerabilityScanRecord
	err := s.db.WithContext(ctx).
		Select("id", "scan_time", "status", "critical_count", "high_count", "medium_count", "low_count", "unknown_count", "total_count", "error").
		Where("id IN ?", imageIDs).
		Find(&records).Error

	if err != nil {
		return nil, fmt.Errorf("failed to get scan summaries: %w", err)
	}

	result := make(map[string]*vulnerability.ScanSummary, len(records))
	for _, record := range records {
		var errStr string
		if record.Error != nil {
			errStr = *record.Error
		}

		result[record.ID] = &vulnerability.ScanSummary{
			ImageID:  record.ID,
			ScanTime: record.ScanTime,
			Status:   vulnerability.ScanStatus(record.Status),
			Summary: &vulnerability.SeveritySummary{
				Critical: record.CriticalCount,
				High:     record.HighCount,
				Medium:   record.MediumCount,
				Low:      record.LowCount,
				Unknown:  record.UnknownCount,
				Total:    record.TotalCount,
			},
			Error: errStr,
		}
	}

	return result, nil
}

// DeleteScanResult deletes the scan result for an image
func (s *VulnerabilityService) DeleteScanResult(ctx context.Context, imageID string) error {
	if s.db == nil {
		return nil
	}

	return s.db.WithContext(ctx).Where("id = ?", imageID).Delete(&models.VulnerabilityScanRecord{}).Error
}

// isTrivyAvailable checks if Trivy CLI is available
func (s *VulnerabilityService) isTrivyAvailable() bool {
	cmd := exec.Command("trivy", "--version")
	err := cmd.Run()
	return err == nil
}

// GetTrivyVersion returns the installed Trivy version
func (s *VulnerabilityService) GetTrivyVersion() string {
	cmd := exec.Command("trivy", "--version")
	output, err := cmd.Output()
	if err != nil {
		return ""
	}
	// Parse version from output like "Version: 0.50.0"
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "Version:") {
			return strings.TrimSpace(strings.TrimPrefix(line, "Version:"))
		}
	}
	return strings.TrimSpace(string(output))
}

// runTrivyScan executes Trivy scan on an image
func (s *VulnerabilityService) runTrivyScan(ctx context.Context, imageName string, imageID string) (*vulnerability.ScanResult, error) {
	// Use per-image locking to allow concurrent scans of different images
	lock := s.getImageLock(imageID)
	lock.Lock()
	defer lock.Unlock()

	// Run Trivy scan with JSON output
	cmd := exec.CommandContext(ctx, "trivy", "image", "--format", "json", "--quiet", imageName)

	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	startTime := time.Now()
	err := cmd.Run()
	duration := time.Since(startTime).Milliseconds()

	if err != nil {
		// Check if it's a context cancellation
		if ctx.Err() != nil {
			return nil, fmt.Errorf("scan cancelled: %w", ctx.Err())
		}
		// Include stderr in error for debugging
		errMsg := err.Error()
		if stderr.Len() > 0 {
			errMsg = fmt.Sprintf("%s: %s", err.Error(), stderr.String())
		}
		return nil, fmt.Errorf("trivy scan failed: %s", errMsg)
	}

	// Parse Trivy JSON output
	var trivyReport vulnerability.TrivyReport
	if err := json.Unmarshal(stdout.Bytes(), &trivyReport); err != nil {
		return nil, fmt.Errorf("failed to parse trivy output: %w", err)
	}

	// Convert Trivy report to our ScanResult format
	result := vulnerability.ConvertTrivyReportToScanResult(&trivyReport, imageID, time.Now(), duration)
	result.ScannerVersion = s.GetTrivyVersion()

	return result, nil
}

// saveScanResult saves the scan result to the database
func (s *VulnerabilityService) saveScanResult(ctx context.Context, result *vulnerability.ScanResult) error {
	if s.db == nil {
		return nil
	}

	s.ensureSummary(result)

	// Convert vulnerabilities to JSON
	var vulnJSON models.StringSlice
	if len(result.Vulnerabilities) > 0 {
		vulnBytes, err := json.Marshal(result.Vulnerabilities)
		if err != nil {
			return fmt.Errorf("failed to marshal vulnerabilities: %w", err)
		}
		vulnJSON = models.StringSlice{string(vulnBytes)}
	}

	var errPtr *string
	if result.Error != "" {
		errPtr = &result.Error
	}

	var summary *vulnerability.SeveritySummary
	if result.Summary != nil {
		summary = result.Summary
	} else {
		summary = &vulnerability.SeveritySummary{}
	}

	record := models.VulnerabilityScanRecord{
		ID:              result.ImageID,
		ImageName:       result.ImageName,
		Status:          string(result.Status),
		ScanTime:        result.ScanTime,
		Duration:        result.Duration,
		CriticalCount:   summary.Critical,
		HighCount:       summary.High,
		MediumCount:     summary.Medium,
		LowCount:        summary.Low,
		UnknownCount:    summary.Unknown,
		TotalCount:      summary.Total,
		Vulnerabilities: vulnJSON,
		Error:           errPtr,
		ScannerVersion:  result.ScannerVersion,
	}

	// Upsert the record
	return s.db.WithContext(ctx).Clauses(clause.OnConflict{
		Columns:   []clause.Column{{Name: "id"}},
		UpdateAll: true,
	}).Create(&record).Error
}

// convertRecordToResult converts a database record to a ScanResult
func (s *VulnerabilityService) convertRecordToResult(record *models.VulnerabilityScanRecord) (*vulnerability.ScanResult, error) {
	result := &vulnerability.ScanResult{
		ImageID:   record.ID,
		ImageName: record.ImageName,
		ScanTime:  record.ScanTime,
		Status:    vulnerability.ScanStatus(record.Status),
		Duration:  record.Duration,
		Summary: &vulnerability.SeveritySummary{
			Critical: record.CriticalCount,
			High:     record.HighCount,
			Medium:   record.MediumCount,
			Low:      record.LowCount,
			Unknown:  record.UnknownCount,
			Total:    record.TotalCount,
		},
		ScannerVersion: record.ScannerVersion,
	}

	if record.Error != nil {
		result.Error = *record.Error
	}

	// Parse vulnerabilities from JSON
	if len(record.Vulnerabilities) > 0 && record.Vulnerabilities[0] != "" {
		var vulns []vulnerability.Vulnerability
		if err := json.Unmarshal([]byte(record.Vulnerabilities[0]), &vulns); err != nil {
			slog.Warn("failed to unmarshal vulnerabilities", "error", err)
		} else {
			result.Vulnerabilities = vulns
		}
	}

	s.ensureSummary(result)

	return result, nil
}

func (s *VulnerabilityService) ensureSummary(result *vulnerability.ScanResult) {
	if result == nil {
		return
	}

	if len(result.Vulnerabilities) == 0 {
		if result.Summary == nil {
			result.Summary = &vulnerability.SeveritySummary{}
		}
		return
	}

	if result.Summary != nil && result.Summary.Total > 0 {
		return
	}

	result.Summary = buildSeveritySummaryFromVulnerabilities(result.Vulnerabilities)
}

func buildSeveritySummaryFromVulnerabilities(vulns []vulnerability.Vulnerability) *vulnerability.SeveritySummary {
	summary := &vulnerability.SeveritySummary{}
	for _, vuln := range vulns {
		switch vuln.Severity {
		case vulnerability.SeverityCritical:
			summary.Critical++
		case vulnerability.SeverityHigh:
			summary.High++
		case vulnerability.SeverityMedium:
			summary.Medium++
		case vulnerability.SeverityLow:
			summary.Low++
		default:
			summary.Unknown++
		}
		summary.Total++
	}
	return summary
}

// logScanEvent logs a vulnerability scan event
func (s *VulnerabilityService) logScanEvent(ctx context.Context, imageID, imageName string, user models.User, success bool, errMsg string) {
	metadata := models.JSON{
		"action":    "vulnerability_scan",
		"imageId":   imageID,
		"imageName": imageName,
		"success":   success,
	}
	if errMsg != "" {
		metadata["error"] = errMsg
	}

	eventType := models.EventTypeImageScan
	if err := s.eventService.LogImageEvent(ctx, eventType, imageID, imageName, user.ID, user.Username, "0", metadata); err != nil {
		slog.WarnContext(ctx, "failed to log vulnerability scan event", "error", err)
	}
}

// stringPtrValueOrEmpty returns the string value from a pointer or empty string if nil
func stringPtrValueOrEmpty(p *string) string {
	if p == nil {
		return ""
	}
	return *p
}
